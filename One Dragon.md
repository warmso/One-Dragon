# 面试问题复习整理一条龙

[TOC]

## iOS相关
#### AFNetworking源码分析


#### 自定义控件


#### 常用的设计模式
##### MVC
##### MVVM
##### 单例
##### 工厂
##### 代理


#### property的关键字
关键字大致分为三类：
###### 原子性
- atomic	用自旋锁给setter加锁去保证读写的原子性，但是此处并不能保证线程安全。所谓的原子性也就是指的在当前的单次写操作是安全的，runtime实现代码中，setter会增加一个临时的引用计数，即使别的线程release当前的变量依然能保证安全。（线程安全是不会读到脏数据）
- nonatomic	不做加锁处理，效率会高很多。

###### 可读写性
- readonly	只生成getter方法，而不生成setter方法
- readwrite	默认是这个，正常生成getter和setter

###### 内存管理语义
- assign	对NSInteger等简单类型（会自动判断系统位数而选择最大的字节数）简单赋值，也可以修饰NS对象，但是不保证内存安全。
- strong 	默认方式，先retain新值，再release旧值，最后再设置为新值
- weak		不retain新值，也不release旧值，类似于简单赋值，但是会在所指对象销毁时自动置nil
- unsafe_unretained	用于对象的修饰，类似于简单赋值，但是不会自动置nil
- copy 		类似于strong，但是不会retain新值，而是拷贝一份，对于不可变对象是浅拷贝，对于可变对象是深拷贝

#### BAD_ACCESS的出现场景

#### 圆角

#### crash
###### crash收集
###### crash救活


#### CALayer

#### runtime

#### runloop

#### 三种多线程
###### NSThread
###### GCD
###### NSOperation



#### 各种多线程锁的对比

#### 内存管理

#### 等同性判定

#### KVC（Key-value coding）键值编码

#### KVO

#### block相关

#### 离屏渲染

#### JSON解析

#### CoreData

#### CocoaPods

#### UITableView优化

#### 响应者链
##### Hit-Test 机制

当用户触摸(Touch)屏幕进行交互时，系统首先要找到响应者（Responder）。系统检测到手指触摸(Touch)操作时，将Touch行为 以UIEvent的方式加入UIApplication事件队列中。UIApplication从事件队列中取出最早的触摸事件进行分发传递到UIWindow进行处理。UIWindow 会通过hitTest:withEvent:方法寻找触碰点所在的视图，这个过程称之为hit-test view。

hitTest 的顺序如下
UIApplication -> UIWindow -> Root View -> ··· -> subview

在顶级视图（Root View）上调用pointInside:withEvent:方法判断触摸点是否在当前视图内；
如果返回NO，那么hitTest:withEvent:返回nil；
** 如果返回YES，那么它会向当前视图的所有子视图发送hitTest:withEvent:消息 **

所有子视图的遍历顺序是从最父层视图一直到到最子层视图，直到有子视图返回非空对象或者全部子视图遍历完毕。
如果有subview的hitTest:withEvent:返回非空对象则A返回此对象，处理结束

注意这个过程，子视图也是根据pointInside:withEvent:的返回值来确定是返回空还是当前子视图对象的。并且这个过程中如果子视图的hidden=YES、userInteractionEnabled=NO或者alpha小于0.1都会被忽略（alpha的子视图也会继承alpha）

如果所有subview遍历结束仍然没有返回对象，则 UIWindow 的hitTest:withEvent:返回self；

系统就是这样通过hit test找到触碰到的视图(Initial View)进行响应。
##### 响应者链 （Responder Chain）
系统通过hit test 机制找到了触碰到的Initial View，但是有时候Initial view并没有或者无法正常处理此次Touch。这个时候，系统便会通过响应者链寻找下一个响应者，以对此次Touch 进行响应。

响应者链顺序如下：

Initial View（首要视图，也就是上一步找到的那个view）-> View Controller（如果存在） -> superview -> ···  -> rootView -> UIWindow -> UIApplication

如果一直到Root View都没有处理这个事件，事件会传递到UIWindow（iOS中有一个单例Window），此时Window如果也没有处理事件，便进入UIApplication，UIApplication是一个响应者链的终点，它的下一个响应者指向nil，以结束整个响应者链。




***











## 数据结构
#### 链表
###### 判断是否有环
###### 判断环周长
###### 判断环交点
###### O（1）时间复杂度删除节点
###### 链表排序
###### 链表的倒数第K个数

#### 红黑树
#### 平衡二叉树
#### 堆
#### 图
###### 克鲁斯卡尔
###### 迪杰斯特拉
###### 广度优先/深度优先遍历
###### 拓扑排序


***






## 算法

***






## 操作系统
#### 进程的状态
![进程的三个状态的转换](https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=6fa1eb1c20a446236ac7ad30f94b196b/574e9258d109b3de9e01750eccbf6c81800a4c1d.jpg)

- 就绪状态（Ready）：
进程已获得除处理器外的所需资源，等待分配处理器资源；只要分配了处理器进程就可执行。就绪进程可以按多个优先级来划分队列。例如，当一个进程由于时间片用完而进入就绪状态时，排入低优先级队列；当进程由I/O操作完成而进入就绪状态时，排入高优先级队列。

- 运行状态(Running)：
进程占用处理器资源；处于此状态的进程的数目小于等于处理器的数目。在没有其他进程可以执行时(如所有进程都在阻塞状态)，通常会自动执行系统的空闲进程。

- 阻塞状态(Blocked)：
由于进程等待某种条件（如I/O操作或进程同步），在条件满足之前无法继续执行。该事件发生前即使把处理器资源分配给该进程，也无法运行。

#### 进程死锁/如何检测
#### 进程与线程的区别
###### 进程是什么
进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。

在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。

- 进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。

- 进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体，我们称其为进程。

- 进程的特性：
-- 动态性：进程的实质是程序在多道程序系统中的一次执行过程，进程是动态产生，动态消亡的。
-- 并发性：任何进程都可以同其他进程一起并发执行
-- 独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位；
-- 异步性：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进
-- 结构特征：进程由程序、数据和进程控制块PCB三部分组成。

- PCB:
1.程序ID（PID、进程句柄）：它是唯一的，一个进程都必须对应一个PID。PID一般是整型数字
2.特征信息：一般分系统进程、用户进程、或者内核进程等
3.进程状态：运行、就绪、阻塞，表示进程现的运行情况
4.优先级：表示获得CPU控制权的优先级大小
5.通信信息：进程之间的通信关系的反映，由于操作系统会提供通信信道
6.现场保护区：保护阻塞的进程用
7.资源需求、分配控制信息
8.进程实体信息，指明程序路径和名称，进程数据在物理内存还是在交换分区（分页）中
9.其他信息：工作单位，工作区，文件信息等 [1] 

###### 线程是什么
在多线程OS中，通常是在一个进程中包括多个线程，每个线程都是作为利用CPU的基本单位，是花费最小开销的实体。线程具有以下属性。

- 轻型实体
线程中的实体基本上不拥有系统资源，只是有一点必不可少的、能保证独立运行的资源。
线程的实体包括程序、数据和TCB。线程是动态概念，它的动态特性由线程控制块TCB（Thread Control Block）描述。TCB包括以下信息：
-- 线程状态。
-- 当线程不运行时，被保存的现场资源。
-- 一组执行堆栈。
-- 存放每个线程的局部变量主存区。
-- 访问同一个进程中的主存和其它资源。
用于指示被执行指令序列的程序计数器、保留局部变量、少数状态参数和返回地址等的一组寄存器和堆栈。

- 独立调度和分派的基本单位。
在多线程OS中，线程是能独立运行的基本单位，因而也是独立调度和分派的基本单位。由于线程很“轻”，故线程的切换非常迅速且开销小（在同一进程中的）。
- 可并发执行。
在一个进程中的多个线程之间，可以并发执行，甚至允许在一个进程中所有线程都能并发执行；同样，不同进程中的线程也能并发执行，充分利用和发挥了处理机与外围设备并行工作的能力。

- 共享进程资源。
在同一进程中的各个线程，都可以共享该进程所拥有的资源，这首先表现在：所有线程都具有相同的地址空间（进程的地址空间），这意味着，线程可以访问该地址空间的每一个虚地址；此外，还可以访问进程所拥有的已打开文件、定时器、信号量机构等。由于同一个进程内的线程共享内存和文件，所以线程之间互相通信不必调用内核。
一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成。

另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。

线程也有就绪、阻塞和运行三种基本状态。

###### 进程和线程的区别
- 地址空间和其它资源（如打开文件）：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。

- 通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。

- 调度和切换：线程上下文切换比进程上下文切换要快得多。

- 在多线程OS中，线程不是一个可执行的实体。


#### 进程的内存分布
#### 进程间通信
#### 堆内存和栈内存
#### 堆区分配的算法
#### 信号量
#### 原子操作
#### 看门狗
#### 虚拟内存
本质上就是对内存地址进行映射，使得进程认为自己拥有连续的，大量的内存，提高内存利用率，降低程序编写难度。

（比如一个程序被系统告知其可用的内存片段是0到100页。而实际上其占用的内存片段可能是分散的，有可能其占用的真正物理范围是70-120页，201页到240页，还有10页在磁盘上面。）

** 第一类：将进程占用的内存地址映射到RAM内其他位置。 **

** 第二类：将进程占用的内存地址映射到磁盘上面。**

** 而我们通俗讲的虚拟内存就是第二类。**


***






## 计算机网络
#### DNS域名系统
###### 
#### 一次网络请求的完整过程
HTTP客户首先发起建立与服务器TCP连接。一旦建立连接，浏览器进程和服务器进程就可以通过各自的** 套接字 **来访问TCP。

客户往自己的套接字发送HTTP请求消息，也从自己的套接字接收HTTP响应消息。类似地，服务器从自己的套接字接收HTTP请求消息，也往自己  的套接字发送HTTP响应消息。
客户或服务器一旦把某个消息送入各自的套接字，这个消息就完全落入TCP的控制之中。

**TCP给HTTP提供一个可靠的数据传输服务**，这意味着由客户发出的每个HTTP请求消息最终将无损地到达服务器，由服务器发出的每个HTTP响应消息最终也将无损地到达客户。分层网络体系结构体现出一个明显优势——HTTP不必担心数据会丢失，也无需关心TCP如何从数据的丢失和错序中恢复出来的细节。这些是TCP和协议栈中更低协议层的任务。

TCP有一个拥塞控制机制。该机制迫使每个新的TCP连接一开始以相对缓慢的速率传输数据，然而只要网络不拥塞，每个连接可以迅速上升到相对较高的速率。这个慢速传输的初始阶段称为缓启动(slow start)。

HTTP服务器不维护客户的状态信息，我们于是 说HTTP是一个** 无状态 **的协议(stateless protocol)。

![](https://s1.ax1x.com/2018/04/16/CewBkQ.png)

** 具体的步骤： **

###### 域名解析
![](https://s1.ax1x.com/2018/04/16/CeB1xI.png)
-- DNS
###### 建立TCP连接，三次握手
###### 客户端向服务端发送HTTP请求报文
###### 四层/七层模型职责过程
###### 服务器响应HTTP请求
###### 客户端对回传的数据做解析
###### 数据展示
###### 断开TCP连接

#### ISO/OSI七层模型各自的职责
#### TCP/IP四层模型各自的职责
#### http和https的区别
#### GET和POST请求的对比
###### 参数
- GET 方法通过 URL 请求来传递用户的数据，将表单内各字段名称与其内容，以成对的字符串连接，置于 action 属性所指程序的 url 后。
-- URL有长度限制（2048个字符）
-- 效率较好
-- 可被收藏为书签
-- 可被缓存
-- URL字符内容容易乱码（只支持ASCII码）

- POST 将表单内各字段名称与其内容放置在 HTML 表头(header)内一起传送给服务器端交由 action 属性能所指的程序处理，该程序会通过标准输入(stdin)方式，将表单的数据读出并加以处理
-- 不会被缓存
-- 不能被收藏为书签
-- 理论上可携带参数的长度没有限制，但是有的服务器会做限制，为了防止恶意攻击。
-- 支持标准字符集

###### 安全
对于服务器来说：
- GET是安全的，因为获取数据是一个只读操作
- POST是相对不安全的，因为提交的数据需要写入数据库


#### http1.0、1.1、2.0版本对比
#### http的状态码
服务器返回的  **响应报文**  中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。

| 状态码 | 类别 | 原因短语 |
| :---: | :---: | :---: |
| 1XX | Informational（信息性状态码） | 接收的请求正在处理 |
| 2XX | Success（成功状态码） | 请求正常处理完毕 |
| 3XX | Redirection（重定向状态码） | 需要进行附加操作以完成请求 |
| 4XX | Client Error（客户端错误状态码） | 服务器无法处理请求 |
| 5XX | Server Error（服务器错误状态码） | 服务器处理请求出错 |

###### 1XX 信息

-  **100 Continue** ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。

###### 2XX 成功

-  **200 OK** 

-  **204 No Content** ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。

-  **206 Partial Content** ：表示客户端进行了范围请求。响应报文包含由 Content-Range 指定范围的实体内容。

###### 3XX 重定向

-  **301 Moved Permanently** ：永久性重定向

-  **302 Found** ：临时性重定向

-  **303 See Other** ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。

	* 注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。*

-  **304 Not Modified** ：如果请求报文首部包含一些条件，例如：If-Match，If-ModifiedSince，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。

-  **307 Temporary Redirect** ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。

###### 4XX 客户端错误

-  **400 Bad Request** ：请求报文中存在语法错误。

-  **401 Unauthorized** ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。

-  **403 Forbidden** ：请求被拒绝，服务器端没有必要给出拒绝的详细理由。

-  **404 Not Found** 

###### 5XX 服务器错误

-  **500 Internal Server Error** ：服务器正在执行请求时发生错误。

-  **503 Service Unavilable** ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

#### TCP的三次握手
#### TCP的四次挥手
#### 拥塞控制
#### 流量控制
#### 滑动窗口
#### 重传
#### TCP和UDP的比较
#### TCP包格式
#### UDP包格式
#### IP协议
#### ARP协议
#### 路由选择
#### 路由转发
#### 以太网帧
#### 曼彻斯特编码

#### 端口监听
#### 对称/非对称加密
#### 套接字

***






## 数据库
#### 范式
#### 索引
###### 索引的分类
###### 索引的实现原理
#### 视图
#### 数据库的优化
#### SQLite的线程安全
#### 